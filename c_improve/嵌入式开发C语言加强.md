# 嵌入式开发C语言加强

## 0. 视频和源码对照表

| 序号 | 视频                          | 源码                                                         |
| ---- | ----------------------------- | ------------------------------------------------------------ |
| 1    | 01_变量和指针                 | 01_var_pointer                                               |
| 2    | 02_sizeof和关键字             | 02_print_sizeof<br />03_keyword                              |
| 3    | 03_struct                     | 04_struct<br />05_struct_space                               |
| 4    | 04_变量赋值                   | 06_var_give_val                                              |
| 5    | 05_通过指针赋值               | 07_pointer_give_val                                          |
| 6    | 06_上午答疑                   | 08_question                                                  |
| 7    | 07\_结构体指针\_函数指针      | 09_struct_pointer<br />10_function_pointer<br />11_use_lcd_by_macro<br />12_use_lcd_by_type<br />13_use_lcd_by_function_pointer |
| 8    | 08\_下午答疑\_关于指针        | 14_questions_pointer                                         |
| 9    | 09_链表                       | 15_list                                                      |
| 10   | 10_链表的插入操作             | 16_list_insert                                               |
| 11   | 11_链表的删除操作             | 17_list_remove                                               |
| 12   | 12_ARM架构和汇编初步体验      |                                                              |
| 13   | 13_全局变量的初始化和栈的引入 |                                                              |
| 14   | 14_局部变量的初始化           | 18_stack                                                     |
|      |                               |                                                              |





## 1. 变量与指针

2个口诀：

* 变量变量，能变，就是能读能写，必定在内存里
* 指针指针，保存的是地址，**32位处理器中地址都是32位的，无论是什么类型的指针变量，都是4字节**----->注意！



## 2. 变量赋值

### 2.1 简单的变量赋值

```c
int a;
a = 1;
a = 'A';
```



### 2.2 关键字

* volatile	修饰的变量表示可以被某些**编译器未知的因素**更改 先看以下示例

  int i=10;
  int j = i；//(1)语句
  int k = i；//(2)语句
这时候编译器对代码进行优化，因为在（1）、（2）两条语句中，i 没有被用作左值。这时候编译器认为i 的值没有发生改变，所以在（1）语句时从内存中取出i 的值赋给j 之后，这个值并没有被丢掉，而是在（2）语句时继续用这个值给k 赋值。编译器不会生成出汇编代码重新从内存里取i 的值，这样提高了效率。但要注意：（1）、（2）语句之间i 没有被用作左值才行。

再看下面的这个：
  volatile int i=10;
  int j = i；//(3)语句
  int k = i；//(4)语句
volatile 关键字告诉编译器i 是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值，因而编译器生成的汇编代码会重新从i 的地址处读取数据放在k 中。这样看来，如果i 是一个寄存器变量或者表示一个端口数据或者是多个线程的共享数据，所以说volatile 可以保证对特殊地址的稳定访问。

> 对于寄存器 比如访问按键上的GPIO值 需要一直访问寄存器里的值----->访问硬件寄存器

**同时修饰一个变量的含义： 表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，变量值可修改，但每次用到该变量的值都要从内存中读取，以防止意外错误。**

* const	只读 编译器优化 可能还是会在内存上 要想放在flash上 可能需要一些选项

* static    修饰全局变量/函数 变量的范围为本页 不加修饰的话 其他.c文件也可以用

  ​			 修饰局部变量的时候 变量的值会保留

* extern   说明这个变量是在外部定义的

使用extern 不需要去找 生成a.o b.o最后链接到一起 一般都在.h文件中使用 extern 声明

- auto    是所有局部变量默认的存储类。auto 只能用在函数内，即 auto 只能修饰局部变量。

- register  存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
 > 定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

静态存储方式：是指在程序运行期间分配固定的存储空间的方式。(全局)
动态存储方式：是在程序运行期间根据需要进行动态的分配存储空间的方式。（局部 不用static）

### 2.2 引入结构体、结构体赋值

struct 是类型 不是变量 只有用了之后才会占内存 不然不占空间

struct 里有char 和int  sizeof(struct)为8 而不是5 为了访问效率高 浪费3个字节

> 程序跑飞 出现乱码 加while(1)

#### 赋值

a=1-------> 写几个字节    4个字节！

注意内存对齐

<img src=".\images\image-20220405212930288.png" alt="image-20220405212930288" style="zoom:33%;" />

<img src=".\images\image-20220405221118398.png" alt="image-20220405221118398" style="zoom:33%;" />结构体的指针赋值<img src=".\images\image-20220405221427131.png" alt="image-20220405221427131" style="zoom:33%;" />

### 2.3 类型转换

int <=== char

struct <=== struct pointer



### 2.4 指针、函数指针



> struct student{
>
> ​	char *name;
>
> ​	int age;
>
> ​	struct student classmate;
>
> };                             //不允许这样定义
>
> typedef struct student{
>
> ​	char *name;
>
> ​	int age;
>
> ​	struct student *classmate;
>
> }student  *pstudent;                             //可以定义
>
> zhangsan.classmate = &lili;
>
> lili.classmate =&zhangsan;
>
> zhangsan.classmate ->name



void (*play_ball)(void);//定义一个函数指针

play_ball = 函数名

这是一个变量 函数指针（4字节） 会分配内存

对于函数 play_ball 和&play_ball是一样的



**函数指针实际例子**

有一个产品 可以兼容A/B两种LCD屏幕 用if....else

但是有很多个屏幕怎么解决？

struct lcd_operation{

int type;

void (*draw_logo)(void);

}lcd_operation,*p_lcd_operation;



lcd_operation xxx_lcds[] = {},{}....

xxx_lcds[type].draw_logo();



 .type = 0    	**C99模式下就可以**

为什么这么做？初始化方便 用{}这种存在一个问题 不需要初始化的值也要赋值 费时费力

## 3. 链表操作







## 4. ARM架构

![](.\images\01_risc.png)



![](.\images\02_risc_calc.png)



## 5. 几条汇编指令

* load 读指令
* store 写指令
* B、BL 跳转指令
* add、sub 加 减
* and/bic  与操作



## 6. 几个核心问题

* 有值的全局变量的初始化

  * 类似memcpy，把Flash上的**数据段**，整体拷贝到RAM

* 初始值为0、没有初始化的全局变量，怎么初始化？

  * 有100万个这样的变量
  * 这100万个变量，都保存在Flash上吗？
  * 这些变量在内存RAM里都放在ZI段
  * 类似memset，把ZI段全部清零

* 才去调用main函数

* 局部变量在哪？

  ----保存在栈中

* 局部变量的初始化

  ----值就在代码里 代码写入

* 栈的作用

  地址从高---->低





函数调用 1记录返回地址 2执行函数

返回地址放入LR（R14）返回地址寄存器 调用多个 会被覆盖-----怎么解决？把LR进栈保存

  

## 7.变量存储地址



操作系统给程序运行的内存非了４个区域：
１　代码区：顾名思义就是存放运行的代码的
２　全局数据区：　存放全局数据和静态数据以及常量．
３　栈区　函数调用时的返回地址，参数压栈，局部变量，返回数据等都存放在栈区．
４　堆区，存放程序动态分配的内存（new，malloc等函数分配的）
栈内存是由系统自己分配和释放的，而堆内存要由程序员自己全全控制的，否则会出现内存泄露．

局部变量保存在栈内存区；
栈内存区的地址是连续的，由系统控制速度较快而
堆内存区的地址是不连续的，它是系统将空闲内存块链接起来的链表，
用户用new/malloc请求分配时，找到第一个满足大小要求的块从链表中删除此节点，
然后分给用户，没有栈内存速度快，但是很灵活。